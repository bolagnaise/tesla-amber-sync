{% extends "base.html" %}

{% block content %}
    <hgroup>
        <h1>Dashboard</h1>
        <h2>Real-time energy monitoring and pricing</h2>
    </hgroup>

    <!-- API Connection Status -->
    <div class="grid">
        <article id="amber-status" style="margin: 0; padding: 1em;">
            <header><strong>Amber Electric</strong></header>
            <p style="margin: 0;"><span class="status-indicator" id="amber-indicator">‚è≥</span> <span id="amber-message">Checking...</span></p>
        </article>

        <article id="tesla-status" style="margin: 0; padding: 1em;">
            <header><strong>Tesla</strong></header>
            <p style="margin: 0;"><span class="status-indicator" id="tesla-indicator">‚è≥</span> <span id="tesla-message">Checking...</span></p>
        </article>
    </div>

    <!-- 5-Minute Detailed Billing Window -->
    <article id="five-min-pricing" style="background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%); color: white; padding: 1.5em;">
        <header style="text-align: center; margin-bottom: 1em;">
            <strong style="font-size: 0.9em; text-transform: uppercase; letter-spacing: 1px;">‚òÄÔ∏è Live 5 Min Price</strong>
            <div id="current-interval-time" style="font-size: 1.1em; font-weight: bold; margin-top: 0.3em;">--:-- - --:--</div>
        </header>
        <div style="display: flex; justify-content: center; gap: 2em; margin-bottom: 1.5em;">
            <div style="text-align: center;">
                <div style="background: rgba(253, 224, 71, 0.95); color: #1e3a8a; border-radius: 50%; width: 180px; height: 180px; display: flex; flex-direction: column; justify-content: center; align-items: center; margin: 0 auto;">
                    <div id="current-general-price" style="font-size: 3.5em; font-weight: bold; line-height: 1;">--¬¢</div>
                    <div style="font-size: 0.9em; margin-top: 0.2em;">/kWh</div>
                    <div id="current-renewables" style="font-size: 1em; margin-top: 0.5em; opacity: 0.8;">--% renewables</div>
                </div>
                <div style="margin-top: 0.5em; font-size: 0.85em; opacity: 0.9;">IMPORT (BUY)</div>
            </div>
            <div style="text-align: center;">
                <div style="background: rgba(34, 197, 94, 0.2); border: 2px solid rgba(34, 197, 94, 0.5); border-radius: 12px; padding: 1em; min-width: 100px;">
                    <div style="font-size: 0.8em; opacity: 0.9; margin-bottom: 0.3em;">‚ö° EXPORT</div>
                    <div id="current-feedin-price" style="font-size: 2em; font-weight: bold;">--¬¢</div>
                    <div style="font-size: 0.8em; opacity: 0.8;">/kWh</div>
                </div>
                <div style="margin-top: 0.5em; font-size: 0.85em; opacity: 0.9;">FEED-IN (SELL)</div>
            </div>
        </div>
        <details style="margin-top: 1em;">
            <summary style="cursor: pointer; font-size: 0.95em; font-weight: bold; padding: 0.5em; background: rgba(255,255,255,0.1); border-radius: 8px;">üìä 30 Min Forecast - 5 Min Intervals</summary>
            <div id="five-min-forecast" style="margin-top: 1em; display: flex; gap: 0.5em; overflow-x: auto; padding: 0.5em 0;">
                <p style="color: rgba(255,255,255,0.7);">Loading forecast...</p>
            </div>
        </details>
    </article>

    <!-- Current Pricing Summary -->
    <article id="pricing-section">
        <header><strong>Current Electricity Pricing (30-min average)</strong></header>
        <div id="pricing-content">
            <p>Loading current prices...</p>
        </div>
    </article>

    <!-- Tesla Battery Status -->
    {% if current_user.tesla_energy_site_id %}
    <article id="battery-section">
        <header><strong>Tesla Powerwall Status</strong></header>
        <div id="battery-content">
            <p>Loading battery status...</p>
        </div>
    </article>
    {% endif %}

    <!-- Tariff Schedule -->
    <article id="tou-schedule-section">
        <header>
            <strong>Electricity Tariff Schedule (Rolling 24h)</strong>
            <div style="float: right;">
                <button id="refresh-schedule-btn" style="font-size: 0.9em; margin-right: 0.5em;">Refresh</button>
                {% if current_user.tesla_energy_site_id and (current_user.teslemetry_api_key_encrypted or current_user.tesla_access_token_encrypted) %}
                <button id="sync-tesla-btn" class="primary" style="font-size: 0.9em;">Sync to Tesla</button>
                {% endif %}
            </div>
        </header>
        <div id="sync-status" style="margin-bottom: 1em;"></div>
        <div id="tou-schedule-content">
            <p>Loading tariff schedule...</p>
        </div>
        <details id="tou-forecast-details" style="margin-top: 1em;">
            <summary>View Buy/Sell Price Chart</summary>
            <canvas id="forecastChart" style="max-height: 300px; margin-top: 1em;"></canvas>
        </details>
    </article>

    <!-- Price History Chart -->
    <article id="price-history-section">
        <header><strong>Price History (Last 24 Hours)</strong></header>
        <canvas id="priceChart" style="max-height: 300px;"></canvas>
    </article>

    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script>
        // Check API status
        async function checkAPIStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();

                // Update Amber status
                const amberIndicator = document.getElementById('amber-indicator');
                const amberMessage = document.getElementById('amber-message');
                if (status.amber.connected) {
                    amberIndicator.textContent = '‚úÖ';
                    amberMessage.textContent = 'Connected';
                    amberMessage.style.color = 'green';
                } else {
                    amberIndicator.textContent = '‚ùå';
                    amberMessage.textContent = status.amber.message;
                    amberMessage.style.color = 'red';
                }

                // Update Tesla status
                const teslaIndicator = document.getElementById('tesla-indicator');
                const teslaMessage = document.getElementById('tesla-message');
                if (status.tesla.connected) {
                    teslaIndicator.textContent = '‚úÖ';
                    teslaMessage.textContent = 'Connected';
                    teslaMessage.style.color = 'green';
                } else {
                    teslaIndicator.textContent = '‚ùå';
                    teslaMessage.textContent = status.tesla.message;
                    teslaMessage.style.color = 'red';
                }

                // If Amber is connected, fetch current prices
                if (status.amber.connected) {
                    await fetchCurrentPrices();
                }

                // If Tesla is connected, fetch battery status
                if (status.tesla.connected) {
                    await fetchTeslaStatus();
                }
            } catch (error) {
                console.error('Error checking API status:', error);
            }
        }

        // Update 5-minute billing window
        function update5MinWindow(prices) {
            const now = new Date();

            // Find current general and feedin prices
            const generalPrice = prices.find(p => p.channelType === 'general');
            const feedinPrice = prices.find(p => p.channelType === 'feedIn');

            if (generalPrice) {
                // Calculate current 5-minute interval
                const currentMinute = now.getMinutes();
                const intervalStart = Math.floor(currentMinute / 5) * 5;
                const intervalEnd = intervalStart + 5;

                const startTime = `${String(now.getHours()).padStart(2, '0')}:${String(intervalStart).padStart(2, '0')}`;
                const endTime = `${String(now.getHours()).padStart(2, '0')}:${String(intervalEnd).padStart(2, '0')}`;

                document.getElementById('current-interval-time').textContent = `${startTime} - ${endTime}`;
                document.getElementById('current-general-price').textContent = `${Math.abs(generalPrice.perKwh).toFixed(0)}¬¢`;
                document.getElementById('current-renewables').textContent = `${generalPrice.renewables || 0}% renewables`;
            }

            if (feedinPrice) {
                document.getElementById('current-feedin-price').textContent = `${Math.abs(feedinPrice.perKwh).toFixed(0)}¬¢`;
            }

            // Fetch and display 5-minute forecast (separate API call)
            generate5MinForecast();
        }

        // Fetch and display real 5-minute interval forecast from Amber API
        async function generate5MinForecast() {
            const forecastDiv = document.getElementById('five-min-forecast');

            try {
                // Fetch 5-minute interval data from API
                const response = await fetch('/api/amber/5min-forecast');
                if (!response.ok) {
                    forecastDiv.innerHTML = '<p style="color: rgba(255,255,255,0.7);">5-minute forecast not available</p>';
                    return;
                }

                const data = await response.json();
                const generalIntervals = data.general || [];
                const feedinIntervals = data.feedIn || [];

                if (generalIntervals.length === 0) {
                    forecastDiv.innerHTML = '<p style="color: rgba(255,255,255,0.7);">No forecast data available</p>';
                    return;
                }

                // Group intervals by 30-minute periods
                const periods = {};
                const now = new Date();
                const currentHour = now.getHours();
                const currentMin = Math.floor(now.getMinutes() / 30) * 30;

                generalIntervals.forEach(interval => {
                    const startTime = new Date(interval.startTime);
                    const hour = startTime.getHours();
                    const minute = startTime.getMinutes();

                    // Determine which 30-min period this belongs to
                    const periodMin = Math.floor(minute / 30) * 30;
                    const periodKey = `${hour}:${String(periodMin).padStart(2, '0')}`;

                    if (!periods[periodKey]) {
                        periods[periodKey] = {
                            hour: hour,
                            minute: periodMin,
                            intervals: [],
                            isCurrent: hour === currentHour && periodMin === currentMin
                        };
                    }

                    // Find matching feedin interval
                    const feedin = feedinIntervals.find(f => f.startTime === interval.startTime);

                    periods[periodKey].intervals.push({
                        time: `${hour}:${String(minute).padStart(2, '0')}`,
                        price: interval.perKwh,
                        feedinPrice: feedin ? feedin.perKwh : null,
                        renewables: interval.renewables || 0,
                        spikeStatus: interval.spikeStatus || 'none'
                    });
                });

                // Generate HTML for each 30-min period
                let html = '';
                const sortedPeriods = Object.values(periods).sort((a, b) => {
                    if (a.hour !== b.hour) return a.hour - b.hour;
                    return a.minute - b.minute;
                });

                sortedPeriods.forEach((period, periodIdx) => {
                    const periodLabel = `${period.hour}:${String(period.minute).padStart(2, '0')}`;
                    const borderStyle = period.isCurrent ? '3px solid #fbbf24' : '1px solid rgba(255,255,255,0.2)';

                    html += `<div style="border: ${borderStyle}; border-radius: 12px; padding: 0.8em; min-width: fit-content; background: ${period.isCurrent ? 'rgba(251, 191, 36, 0.15)' : 'rgba(255,255,255,0.05)'}; margin-right: 0.5em;">`;
                    html += `<div style="display: flex; gap: 0.5em; align-items: center;">`;

                    // Show period label or "NOW"
                    if (period.isCurrent) {
                        html += `<div style="font-size: 0.75em; font-weight: bold; background: #fbbf24; color: #1e3a8a; padding: 0.3em 0.5em; border-radius: 4px;">NOW</div>`;
                    }

                    period.intervals.forEach((interval, idx) => {
                        // Determine circle color based on price
                        let circleColor = '#22c55e'; // green (low)
                        if (Math.abs(interval.price) > 40) {
                            circleColor = '#ef4444'; // red (high)
                        } else if (Math.abs(interval.price) > 20) {
                            circleColor = '#eab308'; // yellow (medium)
                        }

                        // Show spike warning if present
                        let priceSymbol = '‚óè';
                        if (interval.spikeStatus === 'spike') {
                            priceSymbol = '‚ö†Ô∏è';
                        }

                        html += `
                            <div style="text-align: center; min-width: 60px;">
                                ${idx === 0 ? `<div style="font-size: 0.7em; font-weight: bold; margin-bottom: 0.3em;">${interval.time}</div>` : `<div style="font-size: 0.65em; opacity: 0.8; margin-bottom: 0.3em;">${interval.time.split(':')[1]}</div>`}
                                <div style="color: ${circleColor}; font-size: 1.8em; line-height: 1;">${priceSymbol}</div>
                                <div style="font-size: 0.95em; font-weight: bold; margin-top: 0.2em;">${Math.abs(interval.price).toFixed(0)}¬¢</div>
                                <div style="font-size: 0.7em; opacity: 0.7;">${interval.renewables}%</div>
                            </div>
                        `;
                    });

                    html += `</div></div>`;
                });

                forecastDiv.innerHTML = html;

            } catch (error) {
                console.error('Error fetching 5-min forecast:', error);
                forecastDiv.innerHTML = '<p style="color: rgba(255,255,255,0.7);">Error loading forecast</p>';
            }
        }

        // Fetch current Amber prices
        async function fetchCurrentPrices() {
            try {
                const response = await fetch('/api/amber/current-price');
                if (!response.ok) {
                    // Don't spam console if Amber isn't configured
                    if (response.status !== 404 && response.status !== 500) {
                        console.error('Failed to fetch prices:', response.status);
                    }
                    return;
                }
                const prices = await response.json();

                // Update 5-minute billing window
                update5MinWindow(prices);

                const pricingContent = document.getElementById('pricing-content');
                let html = '<div class="grid">';

                prices.forEach(channel => {
                    const spikeColor = channel.spikeStatus === 'spike' ? 'red' :
                                      channel.spikeStatus === 'potential' ? 'orange' : 'green';

                    // Determine channel label and pricing logic
                    let channelLabel = channel.channelType.toUpperCase();
                    let priceValue = channel.perKwh;
                    let spotValue = channel.spotPerKwh;
                    let priceSign = '';

                    if (channel.channelType === 'feedIn') {
                        // Feed-in tariff: negative values mean you receive money for exporting
                        channelLabel = 'FEED-IN (EXPORT)';
                        priceValue = Math.abs(priceValue);
                        spotValue = spotValue ? Math.abs(spotValue) : null;
                        priceSign = '+'; // You receive money
                    } else if (channel.channelType === 'general') {
                        // General usage: normally positive (you pay), but can be negative (you get paid)
                        channelLabel = 'GENERAL (IMPORT)';
                        if (priceValue < 0) {
                            priceValue = Math.abs(priceValue);
                            spotValue = spotValue && spotValue < 0 ? Math.abs(spotValue) : spotValue;
                            priceSign = '+'; // You get paid to import!
                            channelLabel = 'GENERAL (IMPORT - PAID!)';
                        }
                    }

                    // Format spike status
                    let spikeStatus = 'None';
                    if (channel.spikeStatus === 'spike') spikeStatus = 'Active';
                    else if (channel.spikeStatus === 'potential') spikeStatus = 'Potential';

                    // Format data type
                    const dataType = channel.forecast ? 'Forecast' : 'Actual';

                    html += `
                        <article style="margin: 0; padding: 1em; text-align: center;">
                            <header><strong>${channelLabel}</strong></header>
                            <p style="font-size: 2.5em; margin: 0; color: ${spikeColor};">
                                <strong>${priceSign}${priceValue.toFixed(2)}¬¢</strong>
                            </p>
                            <p style="margin: 0.5em 0 0 0; font-size: 0.85em; color: #888;">
                                per kWh
                            </p>
                            <small style="color: #666;">
                                ${spotValue !== null ? `Spot: ${priceSign}${spotValue.toFixed(2)}¬¢<br>` : ''}
                                <strong>Spike:</strong> ${spikeStatus} ‚Ä¢ <strong>Type:</strong> ${dataType}
                            </small>
                        </article>
                    `;
                });

                html += '</div>';
                pricingContent.innerHTML = html;

                // Fetch and update price history
                await fetchPriceHistory();
            } catch (error) {
                console.error('Error fetching current prices:', error);
                document.getElementById('pricing-content').innerHTML =
                    '<p style="color: red;">Error loading prices. Please check your API token in Settings.</p>';
            }
        }

        // Fetch Tesla battery status
        async function fetchTeslaStatus() {
            try {
                const response = await fetch('/api/tesla/status');
                if (!response.ok) {
                    throw new Error('Failed to fetch Tesla status');
                }
                const status = await response.json();

                const batteryContent = document.getElementById('battery-content');
                const batteryLevel = status.percentage_charged || 0;
                const batteryColor = batteryLevel > 80 ? 'green' :
                                    batteryLevel > 50 ? 'orange' : 'red';

                batteryContent.innerHTML = `
                    <div class="grid">
                        <div style="text-align: center;">
                            <p style="font-size: 3em; margin: 0; color: ${batteryColor};">
                                <strong>${batteryLevel.toFixed(0)}%</strong>
                            </p>
                            <p style="margin: 0.5em 0 0 0; color: #888;">Battery Level</p>
                        </div>
                        <div>
                            <p style="margin: 0.5em 0;"><strong>Solar:</strong> ${(status.solar_power / 1000).toFixed(2)} kW</p>
                            <p style="margin: 0.5em 0;"><strong>Battery:</strong> ${(status.battery_power / 1000).toFixed(2)} kW</p>
                            <p style="margin: 0.5em 0;"><strong>Grid:</strong> ${(status.grid_power / 1000).toFixed(2)} kW</p>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('Error fetching Tesla status:', error);
                document.getElementById('battery-content').innerHTML =
                    '<p style="color: red;">Error loading battery status.</p>';
            }
        }

        // Fetch and display price history chart
        let priceChart = null;
        async function fetchPriceHistory() {
            try {
                const response = await fetch('/api/price-history');
                if (!response.ok) {
                    throw new Error('Failed to fetch price history');
                }
                const history = await response.json();

                if (history.length === 0) {
                    return;
                }

                const ctx = document.getElementById('priceChart').getContext('2d');

                // Destroy existing chart if it exists
                if (priceChart) {
                    priceChart.destroy();
                }

                const labels = history.map(record => {
                    const date = new Date(record.timestamp);
                    return date.toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit' });
                });

                const data = history.map(record => record.per_kwh);

                priceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Price (¬¢/kWh)',
                            data: data,
                            borderColor: 'rgb(75, 192, 192)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            tension: 0.1,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                title: {
                                    display: true,
                                    text: 'Price (¬¢/kWh)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error fetching price history:', error);
            }
        }

        // Fetch and display TOU tariff schedule
        let forecastChart = null;
        async function fetchTOUSchedule() {
            try {
                const response = await fetch('/api/tou-schedule');
                if (!response.ok) {
                    throw new Error('Failed to fetch TOU schedule');
                }
                const data = await response.json();

                const content = document.getElementById('tou-schedule-content');
                let html = '';

                // Display stats
                const stats = data.stats;
                if (stats) {
                    html += `<div class="grid" style="margin-bottom: 1em;">
                        <div style="text-align: center;">
                            <p style="margin: 0; font-size: 0.9em; color: #888;">Buy Price Range</p>
                            <p style="margin: 0; font-size: 1.3em;"><strong>${stats.buy.min.toFixed(1)}¬¢ - ${stats.buy.max.toFixed(1)}¬¢</strong></p>
                            <p style="margin: 0; font-size: 0.85em; color: #666;">Avg: ${stats.buy.avg.toFixed(1)}¬¢/kWh</p>
                        </div>
                        <div style="text-align: center;">
                            <p style="margin: 0; font-size: 0.9em; color: #888;">Sell Price Range</p>
                            <p style="margin: 0; font-size: 1.3em;"><strong>${stats.sell.min.toFixed(1)}¬¢ - ${stats.sell.max.toFixed(1)}¬¢</strong></p>
                            <p style="margin: 0; font-size: 0.85em; color: #666;">Avg: ${stats.sell.avg.toFixed(1)}¬¢/kWh</p>
                        </div>
                        <div style="text-align: center;">
                            <p style="margin: 0; font-size: 0.9em; color: #888;">Total Periods</p>
                            <p style="margin: 0; font-size: 1.3em;"><strong>${stats.total_periods}</strong></p>
                            <p style="margin: 0; font-size: 0.85em; color: #666;">30-min intervals</p>
                        </div>
                    </div>`;

                    html += `<p style="font-size: 0.9em; color: #666; margin-bottom: 1em;">
                        Tariff: ${data.tariff_name || 'Unknown'}
                    </p>`;
                }

                // Display tariff table
                const periods = data.periods || [];
                if (periods.length > 0) {
                    html += `<div style="max-height: 400px; overflow-y: auto;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                            <thead style="position: sticky; top: 0; background: #1e1e1e;">
                                <tr style="border-bottom: 2px solid #444;">
                                    <th style="text-align: left; padding: 0.5em;">Time</th>
                                    <th style="text-align: right; padding: 0.5em;">Buy (¬¢/kWh)</th>
                                    <th style="text-align: right; padding: 0.5em;">Sell (¬¢/kWh)</th>
                                </tr>
                            </thead>
                            <tbody>`;

                    periods.forEach((period, i) => {
                        const buyColor = period.buy_price > stats.buy.avg * 1.2 ? '#ff6b6b' :
                                        period.buy_price < stats.buy.avg * 0.8 ? '#51cf66' : '#fff';
                        const sellColor = period.sell_price > stats.sell.avg * 1.2 ? '#51cf66' :
                                         period.sell_price < stats.sell.avg * 0.8 ? '#ff6b6b' : '#fff';

                        html += `<tr style="border-bottom: 1px solid #333;">
                            <td style="padding: 0.5em;">${period.time}</td>
                            <td style="text-align: right; padding: 0.5em; color: ${buyColor}; font-weight: bold;">
                                ${period.buy_price.toFixed(2)}
                            </td>
                            <td style="text-align: right; padding: 0.5em; color: ${sellColor}; font-weight: bold;">
                                ${period.sell_price.toFixed(2)}
                            </td>
                        </tr>`;
                    });

                    html += `</tbody></table></div>`;

                    html += `<p style="font-size: 0.8em; color: #666; margin-top: 1em;">
                        <span style="color: #51cf66;">‚óè</span> Green = Good price &nbsp;
                        <span style="color: #ff6b6b;">‚óè</span> Red = High price &nbsp;
                        <span style="color: #fff;">‚óè</span> White = Average
                    </p>`;
                }

                content.innerHTML = html;

                // Update chart
                if (periods.length > 0) {
                    updateTariffChart(periods);
                }

            } catch (error) {
                console.error('Error fetching TOU schedule:', error);
                document.getElementById('tou-schedule-content').innerHTML =
                    '<p style="color: red;">Error loading tariff schedule. Please check your Amber API configuration in Settings.</p>';
            }
        }

        function updateTariffChart(periods) {
            const ctx = document.getElementById('forecastChart').getContext('2d');

            // Destroy existing chart if it exists
            if (forecastChart) {
                forecastChart.destroy();
            }

            // Extract labels and data from periods
            const labels = periods.map(period => period.time);
            const buyPrices = periods.map(period => period.buy_price);
            const sellPrices = periods.map(period => period.sell_price);

            forecastChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Buy Price (¬¢/kWh)',
                            data: buyPrices,
                            borderColor: 'rgb(255, 99, 132)',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            borderWidth: 2,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            fill: true
                        },
                        {
                            label: 'Sell Price (¬¢/kWh)',
                            data: sellPrices,
                            borderColor: 'rgb(75, 192, 75)',
                            backgroundColor: 'rgba(75, 192, 75, 0.1)',
                            borderWidth: 2,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '¬¢/kWh';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Price (¬¢/kWh)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time (24-hour rolling window)'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 12
                            }
                        }
                    }
                }
            });
        }

        // Sync to Tesla handler
        async function syncTeslaSchedule() {
            const syncBtn = document.getElementById('sync-tesla-btn');
            const syncStatus = document.getElementById('sync-status');

            try {
                // Disable button and show loading state
                syncBtn.disabled = true;
                syncBtn.textContent = 'Syncing...';
                syncStatus.innerHTML = '<p style="color: blue;">‚è≥ Syncing schedule to Tesla Powerwall...</p>';

                const response = await fetch('/api/sync-tesla-schedule', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    syncStatus.innerHTML = `
                        <p style="color: green;">‚úÖ ${result.message}</p>
                        <p style="font-size: 0.9em; margin: 0.5em 0;">
                            Updated ${result.rate_periods} pricing periods to Tesla.
                            Tariff: ${result.tariff_name}
                        </p>
                    `;
                    // Auto-hide success message after 10 seconds
                    setTimeout(() => {
                        syncStatus.innerHTML = '';
                    }, 10000);
                } else {
                    throw new Error(result.error || 'Failed to sync schedule');
                }
            } catch (error) {
                console.error('Error syncing Tesla schedule:', error);
                syncStatus.innerHTML = `<p style="color: red;">‚ùå Error: ${error.message}</p>`;
            } finally {
                // Re-enable button
                syncBtn.disabled = false;
                syncBtn.textContent = 'Sync to Tesla';
            }
        }

        // Refresh button handler
        document.getElementById('refresh-schedule-btn')?.addEventListener('click', fetchTOUSchedule);

        // Sync button handler
        document.getElementById('sync-tesla-btn')?.addEventListener('click', syncTeslaSchedule);

        // Initial load
        checkAPIStatus();
        fetchTOUSchedule();

        // Refresh current prices every 1 minute (Amber updates every 5 mins, so we catch updates quickly)
        setInterval(fetchCurrentPrices, 60 * 1000);
        // Check API status every 5 minutes
        setInterval(checkAPIStatus, 5 * 60 * 1000);
        // Refresh TOU schedule every hour
        setInterval(fetchTOUSchedule, 60 * 60 * 1000);
    </script>

    <style>
        .status-indicator {
            font-size: 1.5em;
        }
    </style>
{% endblock %}
